
import numpy as np
import itertools
import math
from tqdm import tqdm
import scipy

import random
from sympy import *


from numba import jit

@jit
def eval_eq_mod(V, m ):
    x = int(V[0])
    y = int(V[1])
    z = int(V[2])

    # if not less:
    #     x = x%m
    #     y = y%m
    #     z = z%m

    zc = (z*z)%m
    zc = (zc*z)%m

    xq = (x*x)%m
    yq = (y*y)%m


    return abs(xq + yq + 5 - zc - (x*y*z)) %m == 0


def eval_eq(V):
    x = int(V[0])
    y = int(V[1])
    z = int(V[2])

    zc = (z*z*z)

    return (x*x + y*y + 5 - zc - (x*y*z)) == 0


def value_of_eq(V):
    x = int(V[0])
    y = int(V[1])
    z = int(V[2])

    zc = (z*z*z)

    return abs(x*x + y*y + 5 - zc - (x*y*z))

def check_rem(point, number):
    pass


def make_list_of_primes(n):
    primes = []

    for i in range(2, n + 1):
        for j in range(2, int(i ** 0.5) + 1):
            if i%j == 0:
                break
        else:
            primes.append(i)

    return primes


def finder(prime = 997, additional = 100):


    rem = [i for i in range(prime)]
    mult = [i for i in range(additional)]

    for i in tqdm( itertools.product(rem, rem, rem) ):
        d = eval_eq_mod(i, prime)
        if d :
            for j in itertools.product(mult, mult, mult):
                result = eval_eq( (i[0] + prime*j[0],
                                   i[1] + prime*j[1],
                                   i[2] + prime*j[2]))
                if result:
                    print((i[0] + prime*j[0],
                           i[1] + prime*j[1],
                           i[2] + prime*j[2]))
                    break


def finder_random(prime = 997, additional = 100, batch = 20_000):
    temp = []

    rem = [i for i in range(prime)]
    mult = [i for i in range(additional)]

    sec  = np.random.randint(prime, size = (batch, 3))

    for i in tqdm(range(batch)):

        d = eval_eq_mod(sec[i, :], prime)

        if d :
            for j in itertools.product(mult, mult, mult):
                result = eval_eq( (int(sec[i, 0]) + prime*j[0],
                                   int(sec[i, 1]) + prime*j[1],
                                   int(sec[i, 2]) + prime*j[2]))
                if result:
                    print((int(sec[i, 0]) + prime*j[0],
                           int(sec[i, 1]) + prime*j[1],
                           int(sec[i, 2]) + prime*j[2]))
                    break

def finder_random_one(prime = 997, additional = 100, batch = 20_000):
    temp = []

    rem = [i for i in range(prime)]
    mult = [i for i in range(additional)]

    
    for i in tqdm(range(batch)):

        sec  = np.random.randint(prime, size = (3))

        d = eval_eq_mod(sec, prime)

        if d :
            for j in itertools.product(mult, mult, mult):
                result = eval_eq( (int(sec[0]) + prime*j[0],
                                   int(sec[1]) + prime*j[1],
                                   int(sec[2]) + prime*j[2]))
                if result:
                    print((int(sec[0]) + prime*j[0],
                           int(sec[1]) + prime*j[1],
                           int(sec[2]) + prime*j[2]))
                    break

def ex1():
    x, y, z, t = symbols('x y z t')
    k, m, n = symbols('k m n', integer=True)
    f, g, h = symbols('f g h', cls=Function)

    primes = [2*3*4*5*2]#make_list_of_primes(6)
    points = []

    for m, it in zip(primes, range(len(primes))):
        temp = []

        rem =[i for i in range(m)]

        for i in tqdm( itertools.product(rem, rem , rem) ):
            d = eval_eq_mod(i, m)
            if d :
                temp.append(i)

        points.append(temp)


    for i, prime in zip(points, primes):
        rp = []

        for e in i:
            if e[2] not in rp:
                rp.append(e[2])

        i = sorted(i, key = lambda k: k[2])

        i2 = []
        for r in i:
            if r not in i2 and (r[1], r[0], r[2]) not in i2:
                i2.append(r)

        print(prime, len(i2), len(i2)/(prime**3))

        for j in i2 :
            print(j)


        print(sorted(rp))

def climb(point = 0):
    if point == 0:
        current = [8*random.randrange(10**1, 10**5) for i in range(2)] + [16*random.randrange(10**1, 10**5) + 4]
    else :
        current = point

    for j in range(1_0_000):

        current = min( steps8(current), key =  value_of_eq)
        

    print(value_of_eq(current), current)

def steps(P):

    A = [(P[0] + 1, P[1],    P[2]),
        (P[0],      P[1]+1,  P[2]),
        (P[0],      P[1],    P[2]+1),

        (P[0] + 1,  P[1]+1,  P[2]),
        (P[0] + 1,  P[1],    P[2]+1),
        (P[0] + 1,  P[1]+1,  P[2]+1),

        (P[0],      P[1]+ 1, P[2]+1),
        (P[0],      P[1],    P[2]+1)]

    A2 = [(P[0] + 2, P[1],    P[2]),
        (P[0],      P[1]+2,  P[2]),
        (P[0],      P[1],    P[2]+2),

        (P[0] + 2,  P[1]+2,  P[2]),
        (P[0] + 2,  P[1],    P[2]+2),
        (P[0] + 2,  P[1]+2,  P[2]+2),

        (P[0],      P[1]+ 2, P[2]+2),
        (P[0],      P[1],    P[2]+2)]    

    B = [(P[0] - 1, P[1],    P[2]),
        (P[0],      P[1]-1,  P[2]),
        (P[0],      P[1],    P[2]-1),

        (P[0] - 1,  P[1]-1,  P[2]),
        (P[0] - 1,  P[1],    P[2]-1),
        (P[0] - 1,  P[1]-1,  P[2]-1),

        (P[0],      P[1]- 1, P[2]-1),
        (P[0],      P[1],    P[2]-1)]

    v = np.random.choice([2971215073, 11, 5, 3, 1, -1 -5, -3, -11, -13], (13))

    C = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = np.random.choice([2, 3, -5, 13, -89, 233, 1597, 28657, 514229, -433494437, 2971215073], (13))

    C2 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = np.random.choice([2971215073, 997, 97, 5, 3, 1, -1 -5, -3, -97, -997, -9173,
                        2, -17, 257, -1297, 65537, -160001, 331777, 614657, 1336337, 4477457], (13))

    C3 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C4 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C5 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C6 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    return A + A2 + B + C + C2 + C3 + C4 + C5 + C6

def steps8(P):

    A = [(P[0] + 8, P[1],    P[2]),
        (P[0],      P[1]+8,  P[2]),
        (P[0],      P[1],    P[2]+16),

        (P[0] + 8,  P[1]+8,  P[2]),
        (P[0] + 8,  P[1],    P[2]+16),
        (P[0] + 8,  P[1]+8,  P[2]+16),

        (P[0],      P[1]+ 8, P[2]+16),
        (P[0],      P[1],    P[2]+16)]

    A2 = [(P[0] + 8, P[1],    P[2]),
        (P[0],      P[1]+8,  P[2]),
        (P[0],      P[1],    P[2]+16),

        (P[0] + 8,  P[1]+8,  P[2]),
        (P[0] + 8,  P[1],    P[2]+16),
        (P[0] + 8,  P[1]+8,  P[2]+16),

        (P[0],      P[1]+ 8, P[2]+16),
        (P[0],      P[1],    P[2]+16)]    

    B = [(P[0] - 8, P[1],    P[2]),
        (P[0],      P[1]-8,  P[2]),
        (P[0],      P[1],    P[2]-16),

        (P[0] - 8,  P[1]-8,  P[2]),
        (P[0] - 8,  P[1],    P[2]-16),
        (P[0] - 8,  P[1]-8,  P[2]-16),

        (P[0],      P[1]- 8, P[2]-16),
        (P[0],      P[1],    P[2]-16)]

    v = np.random.choice([2971215073, 11, 5, 3, 1, -1 -5, -3, -11, -13], (13))

    C = [(P[0] - 8*v[0], P[1],    P[2]),
        (P[0],      P[1]-8*v[1],  P[2]),
        (P[0],      P[1],    P[2]-16*v[2]),

        (P[0] - 8*v[3],  P[1]-8*v[6],  P[2]),
        (P[0] - 8*v[4],  P[1],    P[2]-16*v[7]),
        (P[0] - 8*v[5],  P[1]-8*v[8],  P[2]-16*v[9]),

        (P[0],      P[1]- 8*v[10], P[2]-16*v[11]),
        (P[0],      P[1],    P[2]-16*v[12])]

    v = np.random.choice([2, 3, -5, 13, -89, 233, 1597, 28657, 514229, -433494437, 2971215073], (13))

    C2 = [(P[0] - 8*v[0], P[1],    P[2]),
        (P[0],      P[1]-8*v[1],  P[2]),
        (P[0],      P[1],    P[2]-16*v[2]),

        (P[0] - 8*v[3],  P[1]-8*v[6],  P[2]),
        (P[0] - 8*v[4],  P[1],    P[2]-16*v[7]),
        (P[0] - 8*v[5],  P[1]-8*v[8],  P[2]-16*v[9]),

        (P[0],      P[1]- 8*v[10], P[2]-16*v[11]),
        (P[0],      P[1],    P[2]-16*v[12])]

    v = np.random.choice([2971215073, 997, 97, 5, 3, 1, -1 -5, -3, -97, -997, -9173,
                        2, -17, 257, -1297, 65537, -160001, 331777, 614657, 1336337, 4477457], (13))

    C3 = [(P[0] -8* v[0], P[1],    P[2]),
        (P[0],      P[1]-8*v[1],  P[2]),
        (P[0],      P[1],    P[2]-16*v[2]),

        (P[0] -8* v[3],  P[1]-8*v[6],  P[2]),
        (P[0] - 8*v[4],  P[1],    P[2]-16*v[7]),
        (P[0] -8* v[5],  P[1]-8*v[8],  P[2]-16*v[9]),

        (P[0],      P[1]- 8*v[10], P[2]-16*v[11]),
        (P[0],      P[1],    P[2]-16*v[12])]

    v = np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C4 = [(P[0] - 8*v[0], P[1],    P[2]),
        (P[0],      P[1]-8*v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] -8* v[3],  P[1]-8*v[6],  P[2]),
        (P[0] - 8*v[4],  P[1],    P[2]-16*v[7]),
        (P[0] - 8*v[5],  P[1]-8*v[8],  P[2]-16*v[9]),

        (P[0],      P[1]- 8*v[10], P[2]-16*v[11]),
        (P[0],      P[1],    P[2]-16*v[12])]

    v = np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C5 = [(P[0] - 8*v[0], P[1],    P[2]),
        (P[0],      P[1]-8*v[1],  P[2]),
        (P[0],      P[1],    P[2]-16*v[2]),

        (P[0] - 8*v[3],  P[1]-8*v[6],  P[2]),
        (P[0] - 8*v[4],  P[1],    P[2]-16*v[7]),
        (P[0] - 8*v[5],  P[1]-8*v[8],  P[2]-16*v[9]),

        (P[0],      P[1]- 8*v[10], P[2]-16*v[11]),
        (P[0],      P[1],    P[2]-16*v[12])]

    v = np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C6 = [(P[0] - 8*v[0], P[1],    P[2]),
        (P[0],      P[1]-8*v[1],  P[2]),
        (P[0],      P[1],    P[2]-16*v[2]),

        (P[0] - 8*v[3],  P[1]-8*v[6],  P[2]),
        (P[0] - 8*v[4],  P[1],    P[2]-16*v[7]),
        (P[0] - 8*v[5],  P[1]-8*v[8],  P[2]-16*v[9]),

        (P[0],      P[1]- 8*v[10], P[2]-16*v[11]),
        (P[0],      P[1],    P[2]-16*v[12])]

    return A + A2 + B + C + C2 + C3 + C4 + C5 + C6

def steps24(P):

    A = [(P[0] + 2, P[1],    P[2]),
        (P[0],      P[1]+2,  P[2]),
        (P[0],      P[1],    P[2]+1),

        (P[0] + 2,  P[1]+2,  P[2]),
        (P[0] + 2,  P[1],    P[2]+2),
        (P[0] + 2,  P[1]+2,  P[2]+2),

        (P[0],      P[1]+ 2, P[2]+2),
        (P[0],      P[1],    P[2]+2)]

    A2 = [(P[0] + 2, P[1],    P[2]),
        (P[0],      P[1]+2,  P[2]),
        (P[0],      P[1],    P[2]+2),

        (P[0] + 2,  P[1]+2,  P[2]),
        (P[0] + 2,  P[1],    P[2]+2),
        (P[0] + 2,  P[1]+2,  P[2]+2),

        (P[0],      P[1]+ 2, P[2]+2),
        (P[0],      P[1],    P[2]+2)]    

    B = [(P[0] - 4, P[1],    P[2]),
        (P[0],      P[1]-1,  P[2]),
        (P[0],      P[1],    P[2]-1),

        (P[0] - 4,  P[1]-4,  P[2]),
        (P[0] - 4,  P[1],    P[2]-4),
        (P[0] - 4,  P[1]-4,  P[2]-4),

        (P[0],      P[1]- 4, P[2]-4),
        (P[0],      P[1],    P[2]-4)]

    v = 4*np.random.choice([2971215073, -2971215073], (13))

    C = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = 4*np.random.choice([2, 3, -5, 13, -89, 233, 1597, 28657, 514229, -433494437, 2971215073], (13))

    C2 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = 4*np.random.choice([2971215073, 997, 97, 5, 3, 1, -1 -5, -3, -97, -997, -9173,
                        2, -17, 257, -1297, 65537, -160001, 331777, 614657, 1336337, 4477457], (13))

    C3 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = 4*np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C4 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = 4*np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C5 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    v = 4*np.random.choice([-11, -31, -61, -101, 151, -211, -281, 661, 911,
     -1051, -1201, 1361, 1531, 1901, 2311, -2531, 3001,
      -3251, -3511, 4651, 5281, 6301, -6661, 7411, -9461,
       -9901, 12251, -13781, 14851, -15401, -18301, 18911,
        -19531, 20161, 22111, 24151, -24851, 25561, -27011, -27751], (13))

    C6 = [(P[0] - v[0], P[1],    P[2]),
        (P[0],      P[1]-v[1],  P[2]),
        (P[0],      P[1],    P[2]-v[2]),

        (P[0] - v[3],  P[1]-v[6],  P[2]),
        (P[0] - v[4],  P[1],    P[2]-v[7]),
        (P[0] - v[5],  P[1]-v[8],  P[2]-v[9]),

        (P[0],      P[1]- v[10], P[2]-v[11]),
        (P[0],      P[1],    P[2]-v[12])]

    return A + A2 + B + C + C2 + C3 + C4 + C5 + C6

if __name__ == "__main__":
    #print((997**3) * 0.001 * 100  / (200* 60 * 60 ))
    #53471161
    #climb( )

    # with open('data.txt') as reader:
    #     for line in reader.readlines()[::-1]:
    #         line =  line.replace("(", ' ')
    #         line =  line.replace(")", ' ')
    #         line =  line.replace(",", ' ')
    #         line = line.split()
    #         nums = [int(i) for i in line]

    #         if len(nums) == 4:
    #             point = nums[1::]
    #             climb(point)
    
    #ex1()

    x, y, z, t = symbols('x y z t')
    k, m, n = symbols('k m n', integer=True)
    f, g, h = symbols('f g h', cls=Function)

    carr = [1,   9,   13,  17,  25,  29,  33,  41,  45,  49,  57,
            65, 73,  77,  81,  89,  93,  97,  105, 109, 113, 121,
            129,137,141, 145, 153, 157, 161, 169, 173, 177, 185,
            193, 201, 205, 209, 217, 225, 233, 237, 241, 249, 257,
            265, 269,273, 281, 285, 289, 297, 301, 305, 313, 321,
            329, 333, 337, 345, 349, 353, 361, 365, 369, 377, 385,
            393, 397,401, 409, 413, 417, 425, 429, 433, 441, 449,
            457, 461, 465, 473, 481, 489, 493, 497, 505]


    #print(len(carr))

    #y2 = 4x3+b2x2-(4b2+20)
    # for i in range(20_000):

    #     c = np.random.choice(carr) + 512*random.randrange(10**5, 10**15)
    #     print (i, c)
    #     r = diophantine(4*x**2 + 4*y**2 + 5 - c**3 - 4*(x*y*c), 0)
    #     if r != set():
    #         print('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
    #         print(r)
    #         print(c)
    #         break
    
    for i in range(20):
        climb()



    

    # r = list (r)
    # r1 = 

    # print(Poly(, t).eval(0))







   